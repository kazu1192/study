# 1章 関数型JavaScriptへのいざない

## 1.1 JavaScriptに関する事実

JavaScript言語は関数型プログラミングの手法をサポートしている。

```javascript
[1, 2, 3].forEach(aleat);
// アラート"1"がポップアップ
// アラート"2"がポップアップ
// アラート"3"がポップアップ
```

Array#forEachメソッドは、引数として渡した関数に配列のそれぞれの要素を順番に渡して実行する。

JavaScriptは、内部処理のために関数を引数として取るような様々な関数やメソッドを用意している。

例として、すべてのJavaScript関数が持つapplyメソッドが挙げられる。このメソッドに関数と配列を渡して呼び出すと、その配列を関数の引数として関数を実行することができる。

ここでapplyを使って、splat関数を作成してみる。このsplat関数に関数を渡して実行すると、新たな関数を生成して戻り値として返す。

```javascript
function splat(fun) {
    return function(array) {
        return fun.apply(null, array);
    };
}

var addArrayElements = splat(function(x, y) { return x + y });

addArrayElements([1, 2]);
//=> 3
```

JavaScriptの関数は、渡す引数のデータ型を問わず、その数も限定されない。そして、任意の時点で実行することができる。

ここでsplatの逆の機能を持つunsplatという関数を作る。unsplatは関数を引数に取り、別の関数を返す。返された関数は、渡された引数をもとの関数に渡して実行する。

```javascript
function unsplat(fun) {
	return function() {
		return fun.call(null, _.toArray(arguments));
	};
}

var joinElements = unsplat(function(array) { return array.join(' ') });

joinElements(1, 2);
//=> 1 2

joinElements('-', '$', '/', '!', ':');
//=> "- $ / ! :"
```

JavaScriptでは、すべての関数内でargumentsというローカル変数にアクセスすることができる。argumentsは配列に似た構造体で、関数呼び出し時に引数として与えられた値を保持する。

## 1.2 関数型プログラミングを始めるために

関数型プログラミングとは、値を抽象の単位に変換する関数を使用して行うプログラミングであり、それらを使ってソフトウェアシステムを構築することである。

関数型プログラミングを実現するための触媒として使用するライブラリはUnderscoreである。Underscoreは殆どの場合において、この簡略化された関数型プログラミングの基本定義に沿っている。

### 1.2.1 なぜ関数型プログラミングが必要なのか

オブジェクト指向プログラミングの主なゴールは問題をパーツに分解することである。同様に、関数型プログラミングも問題をパーツに分解する。しかしこの場合のパーツは関数である。

オブジェクト指向のアプローチは問題を「名詞」のグループに分解する傾向があることに対し、関数型のアプローチでは問題を「動詞」(関数)のグループに分解する傾向がある。オブジェクト指向プログラミングと同様に、よりハイレベルな動作をする大きな関数は、他の複数の小さい関数を紐付け、もしくは「合成」することにより形作られる。

関数のパーツでシステムを構成する方法のひとつとして、関数もしくは合成された関数を通して、与えられた値を異なる値に徐々に「変換」することができる。(例: テキスト->HTML->編集されたHTML)

オブジェクト指向を採用しているシステムでは、オブジェクト間の作用はそれぞれのオブジェクトの内部的な変更を伴い、多数の小さな、もしくはとても小さな状態の変更の集合体としてのシステム全体の状態にたどり着く。

これに対して、関数型のシステムは、観察しておかなければならないような状態変更を最小限に抑えるように務める。したがって、関数型の原則に則って構築されたシステムに新たな機能を加える際には、局所的、そして破壊的データ変換を伴わない(オリジナルデータが決して変更されない)状況下で、新しい関数がどのように動作するのかを理解することのみが求められる。

関数型プログラミングの原則に則ったシステムとは、原料をいれると徐々に製品を組み立てていく組立ラインの機械であると表現できる。

関数型プログラミングとは、命令形プログラミングで構築したシステムをモジュール化するために、可能な限りの明示的な状態変更を取り除く際に発生するものである。(Hughes 1984) 実践的な関数型プログラミングは状態変更を完全に消滅させることではなく、システム内で発生する変更を可能な限り小規模に、少ない回数に抑えることである。

### 1.2.2 抽象単位としての関数

抽象化を行う方法のひとつは、関数がその実装の詳細を隠蔽することである。隠蔽は、UNIXコミュニティで長く親しまれている Butler Lampson の格言を守らせてくれる美しい仕事の単位である。

``` 実行させ、正しく実行させ、早く実行させろ```

同様に、抽象としての関数を使うと Kent Beck のTDD(テスト駆動開発)の格言を満たすことができるようになる。

``` まず実行させ、次に正しく実行させ、そして早く実行させろ```

例えば、エラーや警告をレポートする場合には、次のようなコードを書くことがある。

```javascript
function parseAge(age) {
    if (!_.isString(age)) throw new Error("引数は文字列である必要があります");
    var a;
    
    console.log("ageを数値に変換しようとしています");
    
    a = parseInt(age, 10);
    
    if (_.isNaN(a)) {
        console.log(["ageを数値に変換できませんでした : ", age].join(''));
        a = 0;
    }
    
    return a;
}

parseAge("42");
// ageを数値に変換しようとしています
//=> 42

parseAge(42);
// Error: 引数は文字列である必要があります

parseAge("frob");
// ageを数値に変換しようとしています
// ageを数値に変換できませんでした : frob
//=> 0
```

parseAge関数は記述されたとおりに動作しているが、エラーや警告、そして情報の出力内容を変えたい場合、それぞれを出力する行を適宜変更しなければならない。ここでのよりすぐれたアプローチは、エラーや警告、そして情報を関数に「抽象化」することである。

```javascript
function fail(thing) {
    throw new Error(thing);
}

function warn(thing) {
    console.log(["警告 : ", thing].join(''));
}

function note(thing) {
    console.log(["情報 : ", thing].join(''));
}

function parseAge(age) {
    if (!_.isString(age)) fail("引数は文字列である必要があります");
    var a;
    
    note("ageを数値に変換しようとしています");
    
    a = parseInt(age, 10);
    
    if (_.isNaN(a)) {
        warn(["ageを数値に変換できませんでした : ", age].join(''));
        a = 0;
    }
    
    return a;
}
```

### 1.2.3 カプセル化と隠蔽

JavaScriptは、データ操作を行うメソッドとデータを一緒にカプセル化できるオブジェクトシステムを提供する。カプセル化は特定の要素の可視範囲を制限するために使われることもあり、これをデータ隠蔽(または単に隠蔽)という。JavaScriptのオブジェクトシステムはデータを直接隠蔽する方法は用意していない。そのため、データを隠蔽する場合は、クロージャと呼ばれるものを使用する。クロージャは関数の一種である。

### 1.2.4 動作単位としての関数

データと動作を隠蔽することは(より「軽い」データ変更方法を提供するという副作用をもっている)、関数を抽象の対象の単位にする方法のひとつに過ぎない。抽象の意味とは、個別の基本的な動作を保持し、あちこちで使いまわすための簡単な方法を提供することである。

JavaScriptにおける別の基本的な動作の単位として、コンパレータ(comparator)という考え方がある。コンパレータは２つの値を引数に取り、１つ目の引数が２つ目よりも小さい場合に負の値を、大きい場合に正の値を、そして等しい場合に0を返す。JavaScriptネイティブのArray#sortメソッドもこのような機能を提供しているように見える。